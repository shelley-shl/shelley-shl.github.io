<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  

  
  <title>jsAPI | Hexo</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="javaScript–DOM  BOM API: 接口 一些预先定义的函数Web API 是浏览器的提供的一套操作 DOM 树：文档对象模型 文档—-一个页面就是一个文档，document表示 元素—页面的所有标签都是元素，element表示 节点—- 页面中所有的内容（标签，属性，文本，注释等，node表示 获取元素 12345671.通过id获取2.通过标签名获取 3.通过类名  html5新">
<meta property="og:type" content="article">
<meta property="og:title" content="jsAPI">
<meta property="og:url" content="http://yoursite.com/2020/07/01/jsAPI/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="javaScript–DOM  BOM API: 接口 一些预先定义的函数Web API 是浏览器的提供的一套操作 DOM 树：文档对象模型 文档—-一个页面就是一个文档，document表示 元素—页面的所有标签都是元素，element表示 节点—- 页面中所有的内容（标签，属性，文本，注释等，node表示 获取元素 12345671.通过id获取2.通过标签名获取 3.通过类名  html5新">
<meta property="og:locale" content="en_US">
<meta property="article:published_time" content="2020-07-01T03:07:58.000Z">
<meta property="article:modified_time" content="2020-07-03T13:49:48.000Z">
<meta property="article:author" content="John Doe">
<meta name="twitter:card" content="summary">
  
    <link rel="alternate" href="/atom.xml" title="Hexo" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 4.2.0"></head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">Hexo</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-jsAPI" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2020/07/01/jsAPI/" class="article-date">
  <time datetime="2020-07-01T03:07:58.000Z" itemprop="datePublished">2020-07-01</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      jsAPI
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>javaScript–DOM  BOM</p>
<p>API: 接口 一些预先定义的函数<br>Web API 是浏览器的提供的一套操作</p>
<p>DOM 树：文档对象模型<br> 文档—-一个页面就是一个文档，document表示<br> 元素—页面的所有标签都是元素，element表示<br> 节点—- 页面中所有的内容（标签，属性，文本，注释等，node表示</p>
<h2 id="获取元素"><a href="#获取元素" class="headerlink" title="获取元素"></a>获取元素</h2> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1.通过id获取</span><br><span class="line">2.通过标签名获取 </span><br><span class="line">3.通过类名  html5新增  ie9以上支持</span><br><span class="line">4.document.querySelector(&#39;.nav&#39;);   返回指定选择器的第一个元素对象</span><br><span class="line">5.document.querySelectorAll();</span><br><span class="line">获取body   document.body</span><br><span class="line">获取html   document.documentElement</span><br></pre></td></tr></table></figure>
<h2 id="操作元素："><a href="#操作元素：" class="headerlink" title="操作元素："></a>操作元素：</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">innerText</span><br><span class="line">innerHTML</span><br><span class="line">常见元素属性  src href  title</span><br><span class="line">表单元素属性  type  value 等</span><br><span class="line">元素样式属性   </span><br><span class="line"> className 更改元素样式   this.className&#x3D;&#39;&#39;;</span><br><span class="line"></span><br><span class="line"> 排他思想 ：先干掉其他，再设置自己</span><br><span class="line"></span><br><span class="line"> element.属性   </span><br><span class="line"> getAttribute(&#39;属性&#39;)   获取自定义属性</span><br><span class="line"> setAttribute(&#39;属性&#39;,&#39;值&#39;)   设置自定义属性</span><br><span class="line"> removeAttribute(&#39;属性&#39;) </span><br><span class="line"></span><br><span class="line"> h5自定义属性以data-开头作为属性并且赋值</span><br></pre></td></tr></table></figure>
<h2 id="节点操作"><a href="#节点操作" class="headerlink" title="节点操作"></a>节点操作</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">children     &#x2F;&#x2F;所有子节点</span><br><span class="line">firstChild    ／／第一个子节点（不管是文本还是元素）</span><br><span class="line">firstElementChild     &#x2F;&#x2F;返回第一个子元素节点    兼容性问题</span><br><span class="line">lastChild  </span><br><span class="line">lastElementChild  </span><br><span class="line"></span><br><span class="line">创建节点</span><br><span class="line">document.createElement();</span><br><span class="line">添加节点</span><br><span class="line">node.appendchild();  &#x2F;&#x2F;后面追加元素</span><br><span class="line">node.insertBefore(child,指定元素); &#x2F;&#x2F;前面添加</span><br><span class="line">删除节点</span><br><span class="line">node.removeChild();</span><br><span class="line">复制节点</span><br><span class="line">node.cloneNode(true);   &#x2F;&#x2F;深拷贝，复制标签和内容</span><br></pre></td></tr></table></figure>
<h2 id="动态创建元素-3种方法"><a href="#动态创建元素-3种方法" class="headerlink" title="动态创建元素 3种方法"></a>动态创建元素 3种方法</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">1. document.write()  如果页面加载完毕再调用，页面会发生重绘</span><br><span class="line">2. innerHTMl（）      &#x2F;&#x2F;效率高  创建多个元素效率高（采取数组形式拼接，不要拼接字符串</span><br><span class="line">3. createElement（）  &#x2F;&#x2F;效率低</span><br></pre></td></tr></table></figure>
<h2 id="DOM重点核心"><a href="#DOM重点核心" class="headerlink" title="DOM重点核心"></a>DOM重点核心</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">1.创建 元素  3种方式</span><br><span class="line">2.增加 元素  2种</span><br><span class="line">3.删</span><br><span class="line">4.改  元素属性，元素样式 表单 </span><br><span class="line">5.查   </span><br><span class="line">6.事件</span><br></pre></td></tr></table></figure>
<h2 id="事件高级"><a href="#事件高级" class="headerlink" title="事件高级"></a>事件高级</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">注册事件（绑定事件）</span><br><span class="line"> 1.传统的绑定事件   唯一性，会覆盖</span><br><span class="line"></span><br><span class="line"> 2.方法监听绑定事件   可以绑定多个事件</span><br><span class="line"> element.addEventListener(&#39;click&#39;,fn)  这是一个方法   ie9之前不支持 </span><br><span class="line"> function fn()&#123;</span><br><span class="line">    alert();</span><br><span class="line">   element.removeEventListener(&#39;&#39;,fn)</span><br><span class="line"> &#125;</span><br><span class="line"> attachEvent(&#39;onclick&#39;,function()&#123;&#125;)   &#x2F;&#x2F;必须加on</span><br><span class="line"></span><br><span class="line">删除事件(解绑事件)</span><br><span class="line"></span><br><span class="line">1.传统删除事件  .onclick &#x3D; null;</span><br><span class="line">2.removeEventListener(&#39;&#39;,fn);</span><br><span class="line"></span><br><span class="line">DOM事件流</span><br><span class="line">   事件传播的过程  1.捕获阶段（从上往下）  2.当前目标阶段  3.冒泡阶段（从下往上）</span><br></pre></td></tr></table></figure>
<h2 id="事件对象"><a href="#事件对象" class="headerlink" title="事件对象"></a>事件对象</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">div.onclick &#x3D;  function(event)&#123;</span><br><span class="line">    e &#x3D; event||window.event</span><br><span class="line">    e.type</span><br><span class="line">    e.preventDefault();   &#x2F;&#x2F;阻止跳转</span><br><span class="line">    e.stopPropagation();  &#x2F;&#x2F;阻止事件冒泡</span><br><span class="line">    e.target  &#x2F;&#x2F;(点击)触罚事件对象（元素）</span><br><span class="line">    this      &#x2F;&#x2F;绑定事件对象（元素）</span><br><span class="line">注意：    区别：e.target 点击那个元素就返回那个元素  this 那个元素绑定了点击事件就返回那个元素</span><br><span class="line"></span><br><span class="line">    1.event 就是一个事件对象，当行参来看</span><br><span class="line">    2.不需要传递参数,只有有了事件才会存在</span><br><span class="line">    3.事件对象也有兼容性问题 ie678   window.event</span><br></pre></td></tr></table></figure>
<h2 id="事件委托-代理-委托"><a href="#事件委托-代理-委托" class="headerlink" title="事件委托(代理 委托)"></a>事件委托(代理 委托)</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">作用：只操作一次DOM， 提高性能</span><br><span class="line">原理：不是每个子节点单独设置监听器，而是设在其父节点上，然后利用冒泡原理影响设置每个子节点</span><br><span class="line"></span><br><span class="line">禁用鼠标右键菜单  </span><br><span class="line">document.addEventListener(&#39;contextmenu&#39;,function(e)&#123;&#125;)</span><br><span class="line">禁止鼠标选中</span><br><span class="line">selectstart</span><br><span class="line"></span><br><span class="line">鼠标事件   MouseEvevt</span><br><span class="line"> 1.   鼠标移动事件   mousemover</span><br><span class="line">     mousemover：</span><br><span class="line">     mouseenter：不会冒泡，只触发自身的</span><br><span class="line"></span><br><span class="line"> 2.   鼠标的位置：e.pageX e.pageY</span><br><span class="line"> </span><br><span class="line">键盘事件 </span><br><span class="line">  keyup       键盘弹起       </span><br><span class="line">  keydown     </span><br><span class="line">  onkeypress  键盘按下         不识别功能健</span><br><span class="line"></span><br><span class="line">  e.keycode 健对应的ASCII码值     根据ASCII码值 判断按下的是那个健</span><br><span class="line">  keyup 与 keydown 不区分大小写</span><br></pre></td></tr></table></figure>
<h2 id="BOM"><a href="#BOM" class="headerlink" title="BOM"></a>BOM</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   浏览器对象模型   其核心对象是window</span><br><span class="line">   window 对象是浏览器的顶级对象 </span><br><span class="line">  1. window.onload &#x3D; function()&#123;&#125; </span><br><span class="line">  2. window.addEventListener(&#39;load&#39;,function()&#123;&#125;)    页面加载完之后再执行   </span><br><span class="line">     window.addEventListener(&#39;pageshow&#39;,function(e)&#123;</span><br><span class="line">         e.persisted  返回的是true，如果这个页面是从缓存取过来的页面，也需要重新计算</span><br><span class="line">     &#125;)  &#x2F;&#x2F;重新加载页面的触发事件</span><br><span class="line"></span><br><span class="line">  3. document.addEventListener(&#39;DOMContentLoaded&#39;,function()&#123;&#125;)   &#x2F;&#x2F;dom加载完毕，不包含图片，css等就可以执行  加载速度更快</span><br><span class="line"></span><br><span class="line">  获取屏幕大小</span><br><span class="line"></span><br><span class="line">  ## 定时器   setTimeout(回调函数，延迟时间)  时间是毫秒，省略会立即执行</span><br><span class="line">  停止定时器  clearTimeout(定时器名)</span><br><span class="line">  setInterval(回调函数，延迟时间)</span><br><span class="line">  clearInterval(定时器名)</span><br><span class="line">&#96;&#96;&#96; </span><br><span class="line">  ##  this</span><br></pre></td></tr></table></figure>
<p>  指向谁在函数定义的时候是确定不了的，只有在函数执行的时候才能确定this指向谁，一般情况下this指向那个调用他的对象<br>  1.在全局作用域下或者普通的函数中：this 指向window（定时器指向也是window）<br>  2.方法中this谁调用指向谁<br>  3.构造函数中this指向构造函数实例 （实例对象  new）<br>  4.原型对象函数里面的this，指向的是 实例对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">## js执行机制 (事件循环)</span><br></pre></td></tr></table></figure>
<p> js多线程  –多核 CPU的能力  （新的js允许）<br>  同步：（主线程执行栈）<br>  异步：（消息队列） js的异步是通过回调函数实现的，有以下3个类型<br>    1.普通事件<br>    2.资源加载<br>    3.定时器</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## location对象</span><br></pre></td></tr></table></figure>
<p>URl：互联网上标准资源地址<br>location 获取资源地址<br>location.href<br>location对象方法<br>location.assign();   //记录浏览历史，实现后退功能<br>location.replace();  //无法后退<br>location.reload();    //重新刷新   参数true 会强制刷新</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## navigator对象</span><br></pre></td></tr></table></figure>
<p>navigator.userAgent   //判断那个终端打开的页面</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## PC网页特效</span><br></pre></td></tr></table></figure>
<p> offset 偏移量(动态得到元素的位置,大小)<br>它以带有定位的父亲为准,如果没有父亲或者父亲没有定位，则以body为准</p>
<p> offset与style的区别<br> offset 只能读取，不可改变<br> style  可读可写</p>
<p> (function(){})()  立即执行函数，不需要调用，立马能够自己执行的函数,独立创建了一个作用域，里面所有的变量都是局部变量</p>
<p> filebox.js文件</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">##  移动端</span><br></pre></td></tr></table></figure>
<p>  touch 事件<br>  touchEvent 触摸事件对象</p>
<p>  移动端常用的开发插件<br>  Swiper插件： <a href="http://www.swiper.com.cn" target="_blank" rel="noopener">www.swiper.com.cn</a><br>  superslide:  <a href="http://www.superslide2.com" target="_blank" rel="noopener">www.superslide2.com</a><br>  iscroll：<br>  zy.media.js插件  处理视频文件</p>
<p>  移动端常用的开发框架  Bootstrap框架</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 本地存储</span><br></pre></td></tr></table></figure>
<p>sessionStorage  生命周期是关闭浏览器窗口</p>
<p>localStorage    生命周期永久生效(不同页面也可用)</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 面向对象</span><br></pre></td></tr></table></figure>
<p> 俩大编程思想：<br> 面向过程： 朝着步骤  就是分析出解决问题所需要的步骤   性能高   适合硬件<br> 面向对象（OOP）： 是以对象功能来划分问题，而不是步骤</p>
<p> 面向对象的特性： 灵活，可复用，易维护<br> 封装<br> 继承<br> 多态</p>
<p> 类是抽象了对象的公共部分<br> 对象是特指某一个，通过类实例化产生的具体对象</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 1.  创建类：</span><br></pre></td></tr></table></figure>
<p> 1.类名首字母大写<br> 2.类里面有constructor函数，<br> 3.constructor函数 ，new生成实例，就会自动调用这个函数，如果不写这个函数，也会自动生成这个函数<br> 4. 类里添加方法    不需要添加function  多个方法之间不用添加逗号</p>
<p>  class 类名{<br>     constructor(){<br>         supter();   ／/ super 必须在this的前面<br>         this.name = name;<br>     }<br>    say(){</p>
<pre><code>}</code></pre><p>  }<br>  实例化  new 类名();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 2.  类的继承</span><br></pre></td></tr></table></figure>
<p>继承中的属性或者方法的查找原则：就近原则<br>extends  子类继承父类<br>super()  子类中的值传给父类<br>    class  sun  extends father{<br>        constructor(){<br>             super()   //调用了父类的构造函数 ，也可调用父类的普通函数 super.say()<br>        }<br>    }<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## es6 中类和对象</span><br></pre></td></tr></table></figure><br>注意； es6中类没有变量提升，所以要先定义类，才能通过类实例化对象<br>      类中的属性和方法一定要加this</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 3. 构造函数和原型</span><br></pre></td></tr></table></figure>
<h2 id="1-构造函数原型-；prototype对象"><a href="#1-构造函数原型-；prototype对象" class="headerlink" title="1.构造函数原型 ；prototype对象"></a>1.构造函数原型 ；prototype对象</h2><p> 作用：共享方法<br>注意； 一般情况下，我们的公共属性定义到构造函数里面，公共的方法我们放到原型对象身上</p>
<p>functon Star(name){<br>    this.name = name;<br>}<br>Star.prototype.sing = function(){</p>
<p>}<br>var ldh = new Star(‘刘德华’);<br>ldh.sing();</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  2. 对象原型 __proto__</span><br></pre></td></tr></table></figure>
<p> 对象身上系统自带<strong>proto</strong>,指向我们构造函数的原型对象prototype<br> <strong>proto</strong>对象原型和原型对象prototype是等价的</p>
<p>注意：constructor() 构造函数 主要用于记录该对象引用了那个构造函数，他可以让原型对象重新指向原来的构造函数</p>
<p>很多情况下，如果修改了原型对象，给原型对象赋值为一个对象，我们需要手动利用constructor这个属性指回原来的构造函数<br> <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">##  原型链</span><br></pre></td></tr></table></figure><br>  javaScript成员查找机制 （<strong>proto</strong>）<br>   1.当访问一个对象的属性（包括方法），首先查找这个对象本身，<br>   如果没有就查找他的prototype原型对象<br>   如果还没有就查找Object的原型对象<br>   一直找到Object为null为止</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## es5新增的方法</span><br></pre></td></tr></table></figure>
<ol>
<li>数组<br>forEach()<br>filter() // 主要作用是筛选数组<br>map()<br>some()   //检查数组中的元素是否满足指定条件，满足true</li>
</ol>
<p>2.字符串<br> trim()   //去除字符串2端的空白字符串</p>
<p>3.对象<br>Object.keys()   // 获取对象自身所有的属性名  返回一个新数组<br>Object.defineProperty(obj,id,{}) // 定义或者修改属性</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 函数进阶</span><br></pre></td></tr></table></figure>
<ol>
<li><p>3种函数的定义</p>
</li>
<li><p>6种函数的调用   this指向  函数的调用方式决定了this的指向<br>1.普通函数     this    指向window<br>2.对象的方法   this  指向的是对象<br>3.构造函数     this  指向实例对象<br>4.绑定事件函数  this  指向函数的调用者<br>5.定时器函数    this  指向window<br>6.立即执行函数   this  指向window</p>
</li>
<li><p>改变函数内部this指向<br>call()     //继承<br>bind()<br>apply()   //跟数组有关系</p>
</li>
</ol>
<p>严格模式:  消除了不合理的地方，提高了编译效率<br>开启严格模式  1.整个脚本开启(script标签)   ‘use strict’<br>            2.函数开启严格模式    </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 高阶函数</span><br></pre></td></tr></table></figure>
<p>  接受一个函数为参数   </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 闭包</span><br></pre></td></tr></table></figure>
<p>有权访问另一个函数作用域中变量的函数      是函数<br>外面的作用域访问函数内部的局部变量  return<br>作用：延伸了变量的作用范围</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">## 递归函数</span><br></pre></td></tr></table></figure>
<p>：函数内部自己调用自己，这个函数就是递归  必须加退出条件  return</p>
<pre><code></code></pre>
      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2020/07/01/jsAPI/" data-id="ckc2sgca00000tsjh6wkwc4om" class="article-share-link">Share</a>
      
      
    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2020/07/03/Vuejs/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Vuejs
        
      </div>
    </a>
  
  
    <a href="/2020/06/23/javascript/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">javascript</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/html-css/" rel="tag">html+css</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/html-css/" style="font-size: 10px;">html+css</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/07/">July 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/06/">June 2020</a></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2020/05/">May 2020</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2020/07/03/Vuejs/">Vuejs</a>
          </li>
        
          <li>
            <a href="/2020/07/01/jsAPI/">jsAPI</a>
          </li>
        
          <li>
            <a href="/2020/06/23/javascript/">javascript</a>
          </li>
        
          <li>
            <a href="/2020/05/26/css/">css</a>
          </li>
        
          <li>
            <a href="/2020/05/26/es6-down/">es6-down</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2020 John Doe<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  
<link rel="stylesheet" href="/fancybox/jquery.fancybox.css">

  
<script src="/fancybox/jquery.fancybox.pack.js"></script>




<script src="/js/script.js"></script>




  </div>
</body>
</html>